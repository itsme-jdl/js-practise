//js is dynamic, automatically considers what to assigns

const a = 1
var b = 2  /* block scoped */
let c = 3  /* braces/fxn scoped */

let d   //undefined value, if not initialised

//null -> empty value
//undefined -> no value is assigned

// console.table([a, b, c, d])
// console.log(typeof null); // -> object type
// console.log(typeof undefined); // -> undefined

//--------------------------------------------------
//Conversions

// "22" -> 22
// "22asdf" -> NaN -> typeof mein prints number 

// ---------------------------------------------

// Data types

// primitive -> value is passed and changes are made in new copy
// String, Number, Boolean, null, undefined, BigInt, symbol;


//Non-primitive or Reference -> direct reference is passed
// Objects, arrays, fxns
//return an object

// stack -> primitive
// heap -> non primitive

//eg:

let userOne = {
    name: "user",
    email: "test@user.com"
}

let userTwo = userOne;
userTwo.email = "test@username.com"; // it changes values in both objects, as same memory is being referenced

// ------------------------------------------------------
// Strings

let name = "Anurag";
let str = `My name is ${name}`; //modern way of defining strings
// console.log(str);

let subName = name.substring(0,2); // dosen't takes -ve values
//string is an object

// name.slice(-8,0) --> takes -ve value as well
//name.trim() -> removes white spaces
//name.replace(oldVal, newVal) -> replaces oldVal with newVal

//name.includes("anu") --> gives true/false
//name.split(deliminator) --> splits based on deliminators

let min = 10;
let max = 20;
//console.log(Math.floor(Math.random() * (max-min+1)) + min)

//--------------------------------------------------------

//Dates

// date are objects
// console.log(Math.floor(Date.now()/1000)) // --> gives current time in seconds

let newDate = new Date();
newDate.toLocaleString('default', {
    weekday: "long"
})


// ---------------------------------------------------------------------

// Arrays

// copy created is shallow copy, i.e. same memory is being referenced

let arr = [1,2,3,4,5,6,7]
console.log("A", arr);

let newArr = arr.slice(1,3)
console.log(newArr);
console.log("B", arr);


let newSpliceArr = arr.splice(1,3)
// console.log(newSpliceArr);
// console.log("C", arr);

//splice includes ranges mentioned from start to end, slice includes from start to end-1
//splice modifies (removes the range mentioned from) the orignal array, but slice dosen't


let newArrFinal = [...newArr, ...newSpliceArr] //-> used to concat two or more arrays

// console.log(Array.isArray("Anurag"));
// console.log(Array.from("Anurag"));
// console.log(Array.from({name: "Anurag"})); --? return empty array, as unable to create an array out of it

let score1 = 100
let score2 = 200

// console.log(Array.of(score1, score2));

// -----------------------------------------------------------

// Objects

// constructors always creates singleton objects
// Object.create()

const mySym = Symbol("key1"); 

let myObj = {
    name: "Anurag",
    "full-name": "Anurag Tiwari", 
    age: 18,
    email:"anu@test.com",
    [mySym]: "mykey"
}

// console.log(myObj.age)
// console.log(myObj["age"]) both are same, as js treats key as strings
// console.log(myObj["full-name"])
// console.log(myObj[mySym]) --> syntax for accessing symbols

Object.freeze(myObj) //--> treats the objects as const, so no change is psible, also no error








